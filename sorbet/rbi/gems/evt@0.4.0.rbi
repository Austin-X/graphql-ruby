# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `evt` gem.
# Please instead update this file by running `bin/tapioca gem evt`.

# source://evt//lib/evt/version.rb#3
module Evt; end

# source://evt//lib/evt/backends/bundled.rb#3
class Evt::Bundled
  # @return [Bundled] a new instance of Bundled
  #
  # source://evt//lib/evt/backends/bundled.rb#7
  def initialize; end

  # Block the calling fiber.
  #
  # source://evt//lib/evt/backends/bundled.rb#120
  def block(blocker, timeout = T.unsafe(nil)); end

  # Invoked when the thread exits.
  #
  # source://evt//lib/evt/backends/bundled.rb#149
  def close; end

  # Collect closed streams in readables and writables
  #
  # source://evt//lib/evt/backends/bundled.rb#154
  def collect(force = T.unsafe(nil)); end

  # source://evt//lib/evt/backends/bundled.rb#88
  def current_time; end

  # Intercept the creation of a non-blocking fiber.
  #
  # source://evt//lib/evt/backends/bundled.rb#177
  def fiber(&block); end

  # Wait for the given file descriptor to match the specified events within
  # the specified timeout.
  #
  # source://evt//lib/evt/backends/bundled.rb#98
  def io_wait(io, events, duration); end

  # Sleep the current task for the specified duration, or forever if not
  # specified.
  #
  # @param duration [Numeric] The amount of time to sleep in seconds.
  #
  # source://evt//lib/evt/backends/bundled.rb#111
  def kernel_sleep(duration = T.unsafe(nil)); end

  def kqueue_init_selector; end
  def kqueue_register(_arg0, _arg1); end
  def kqueue_wait; end

  # source://evt//lib/evt/backends/bundled.rb#25
  def next_timeout; end

  # Returns the value of attribute readable.
  #
  # source://evt//lib/evt/backends/bundled.rb#21
  def readable; end

  # source://evt//lib/evt/backends/bundled.rb#37
  def run; end

  def select_wait; end

  # Unblock the specified fiber.
  #
  # source://evt//lib/evt/backends/bundled.rb#142
  def unblock(blocker, fiber); end

  # Returns the value of attribute waiting.
  #
  # source://evt//lib/evt/backends/bundled.rb#23
  def waiting; end

  # Returns the value of attribute writable.
  #
  # source://evt//lib/evt/backends/bundled.rb#22
  def writable; end

  class << self
    def kqueue_backend; end
    def select_backend; end
  end
end

# source://evt//lib/evt/backends/bundled.rb#5
Evt::Bundled::COLLECT_COUNTER_MAX = T.let(T.unsafe(nil), Integer)

# source://evt//lib/evt/backends/bundled.rb#4
Evt::Bundled::MAXIMUM_TIMEOUT = T.let(T.unsafe(nil), Integer)

class Evt::Bundled::Payload; end

# source://evt//lib/evt/backends/epoll.rb#3
class Evt::Epoll < ::Evt::Bundled
  # source://evt//lib/evt/backends/epoll.rb#20
  def deregister(io); end

  # source://evt//lib/evt/backends/epoll.rb#12
  def init_selector; end

  # source://evt//lib/evt/backends/epoll.rb#24
  def io_wait(io, events, duration); end

  # source://evt//lib/evt/backends/epoll.rb#16
  def register(io, interest); end

  # finished
  # end
  #
  # source://evt//lib/evt/backends/epoll.rb#74
  def wait; end

  class << self
    # @return [Boolean]
    #
    # source://evt//lib/evt/backends/epoll.rb#4
    def available?; end

    # source://evt//lib/evt/backends/epoll.rb#8
    def backend; end
  end
end

# source://evt//lib/evt/backends/iocp.rb#3
class Evt::Iocp < ::Evt::Bundled
  # source://evt//lib/evt/backends/iocp.rb#18
  def deregister(io); end

  # source://evt//lib/evt/backends/iocp.rb#10
  def init_selector; end

  # source://evt//lib/evt/backends/iocp.rb#21
  def io_read(io, buffer, offset, length); end

  # source://evt//lib/evt/backends/iocp.rb#25
  def io_write(io, buffer, offset, length); end

  # source://evt//lib/evt/backends/iocp.rb#14
  def register(io, interest); end

  # source://evt//lib/evt/backends/iocp.rb#29
  def wait; end

  class << self
    # IOCP is totally disabled for now
    #
    # @return [Boolean]
    #
    # source://evt//lib/evt/backends/iocp.rb#6
    def available?; end
  end
end

# source://evt//lib/evt/backends/kqueue.rb#3
class Evt::Kqueue < ::Evt::Bundled
  # source://evt//lib/evt/backends/kqueue.rb#20
  def deregister(io); end

  # source://evt//lib/evt/backends/kqueue.rb#12
  def init_selector; end

  # source://evt//lib/evt/backends/kqueue.rb#16
  def register(io, interest); end

  # source://evt//lib/evt/backends/kqueue.rb#23
  def wait; end

  class << self
    # @return [Boolean]
    #
    # source://evt//lib/evt/backends/kqueue.rb#4
    def available?; end

    # source://evt//lib/evt/backends/kqueue.rb#8
    def backend; end
  end
end

# The major class for Ruby Fiber Scheduler
#
# @example
#   scheduler = Evt::Scheduler.new
#   Fiber.set_scheduler scheduler
#   scheduler.run
#
# source://evt//lib/evt/scheduler.rb#9
class Evt::Scheduler
  class << self
    # Returns all available backends on this machine
    #
    # source://evt//lib/evt/scheduler.rb#30
    def availables; end

    # Returns the fastest possible scheduler
    # Use the backend scheduler directly if you want to choose it yourself
    #
    # source://evt//lib/evt/scheduler.rb#22
    def new; end
  end
end

# source://evt//lib/evt/backends/select.rb#3
class Evt::Select < ::Evt::Bundled
  # source://evt//lib/evt/backends/select.rb#20
  def deregister(io); end

  # source://evt//lib/evt/backends/select.rb#12
  def init_selector; end

  # source://evt//lib/evt/backends/select.rb#16
  def register(io, interest); end

  # source://evt//lib/evt/backends/select.rb#23
  def wait; end

  class << self
    # @return [Boolean]
    #
    # source://evt//lib/evt/backends/select.rb#4
    def available?; end

    # source://evt//lib/evt/backends/select.rb#8
    def backend; end
  end
end

# source://evt//lib/evt/backends/uring.rb#3
class Evt::Uring < ::Evt::Bundled
  # source://evt//lib/evt/backends/uring.rb#20
  def deregister(io); end

  # source://evt//lib/evt/backends/uring.rb#12
  def init_selector; end

  # source://evt//lib/evt/backends/uring.rb#16
  def register(io, interest); end

  # def io_write(io, buffer, offset, length)
  #   uring_io_write(io, buffer, offset, length)
  # end
  #
  # source://evt//lib/evt/backends/uring.rb#32
  def wait; end

  class << self
    # @return [Boolean]
    #
    # source://evt//lib/evt/backends/uring.rb#4
    def available?; end

    # source://evt//lib/evt/backends/uring.rb#8
    def backend; end
  end
end

# source://evt//lib/evt/version.rb#4
Evt::VERSION = T.let(T.unsafe(nil), String)
